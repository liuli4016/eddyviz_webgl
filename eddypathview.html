<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Event View</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">		
		
		<script type="text/javascript" src="../eddyviz_webgl/lib/three.js"></script>
    <script type="text/javascript" src="../eddyviz_webgl/lib/Stats.js"></script>
    <script type="text/javascript" src="../eddyviz_webgl/lib/TrackballControls.js"></script>
    <script type="text/javascript" src="../eddyviz_webgl/lib/Detector.js"></script>
    <script type="text/javascript" src="../eddyviz_webgl/lib/dat.gui.js"></script>
    <!--  <link type="text/css" rel="stylesheet" href="dat-gui-swec.css"> -->
	  <script type="text/javascript" src="../eddyviz_webgl/lib/THREEx.KeyboardState.js"></script>
    <script type="text/javascript" src="../eddyviz_webgl/lib/THREEx.FullScreen.js"></script>
    <script type="text/javascript" src="../eddyviz_webgl/lib/THREEx.WindowResize.js"></script>
		
		<style>			
			body 
			{
				color: #000;
				font-family:Monospace;
				font-size:11px;
				background-color: #fff;
				margin: 0px;
			}
			

			#content 
			{
				position: absolute;
				top: 0px; 
				left: 90%;
				width: 130px;
				z-index: 1;
				padding: 1em 0 0 0;
			}
			
			
			#maincontent 
			{
				position: fixed;
				top: 3px; 
				left: 3px;
				width: 1300px;
				z-index: 1;
				padding: 3em 0 0 0;
			}
			
			#gui
			{
        transform:translate(0, -85px);
      }
      
      
      #inset  
      {
        width: 270px;
        height: 180px;
        border: 0px rgba(200,200,200,0.0) solid;
        background-color: rgba(235,235,235,0.75); /* or transparent; will show through only if renderer alpha: true */
        margin: 3px;
        padding: 0px;
        position: fixed;
        left: -1px;
        bottom: -3px;
        z-index: 1;
      }
			
			
			#mycanvas
			{
				position: fixed;
				left: 0px;
				width: 100%;
				height: 100%;
			}
			
			
			
			#colorbarcanvas
			{
				position: fixed;
				left: 40%;
				top: 10px;
				width: 350px;
				height: 100px;
			}
		  
			
			
			.main-item 
			{
				display: inline-block;
				margin: 1em;
				padding: 1em;
			}
			
			.main-item .graph 
			{
				width: 1300px;
				height: 1000px;
			}
			
			

			.list-item 
			{
				display: inline-block;
				margin: 0.25em;
				padding: 0.25em;
				box-shadow: 1px 2px 3px 0px rgba(240,240,240,0.1);
			}

			.list-item .scene 
			{
				width: 120px;
				height: 120px;
				background-color: rgba(0,0,0,0.05);
			}

			.list-item .description 
			{
				color: #888;
				font-family: sans-serif;
				font-size: large;
				width: 120px;
				margin-top: 0.1em;
			}
			
			
			.longtext {
        line-height: 13px !important;
        height: 40px !important;
    }
    
    .full_width {
        width: 100% !important;
    }
			
			
		</style>
	</head>
	

<body>

<canvas id="mycanvas"></canvas>		
<canvas id="colorbarcanvas"></canvas>	

<input id="myInput" type="file" style="visibility:hidden"/>

<div id="content"> </div>
<div id="maincontent"> </div>

<script id="template" type="notjs">
	<div class="scene"></div>
	<div class="description">Eddy $</div>
</script>



<script id="maintemplate" type="notjs">
	<div class="graph"></div>
</script>


<div id="inset"> </div>		
		
<script>
			
var canvas, content, maincontent, template, container2, gui, eddypro;
var mainscene, mainmesh, selectedmesh, maincamera, camera2, renderer, renderer2, currentmesh;
var trackballControls;
var scenes = [];
var scene2;
var elementlist = [], meshlist = [], geometrylist = [], materiallist = [], targetList = [];
var cx_array = [], cy_array = [], cz_array = [],  depth_array = [], radius_array = [], mapradius_array = [], volume_array = [], minmaxarray = [];
var temparray0 = [], redarray0 = [], greenarray0 = [], bluearray0 = [];
var temparray1 = [], redarray1 = [], greenarray1 = [], bluearray1 = [];
var temparray2 = [], redarray2 = [], greenarray2 = [], bluearray2 = [];
var temparray3 = [], redarray3 = [], greenarray3 = [], bluearray3 = [];

var filename = "", dateperiod = "";
var legendleft = 0, legendright = 0;

var mainmat = new THREE.MeshBasicMaterial({ color: 0xffffff, vertexColors: THREE.VertexColors, transparent: true, blending: THREE.MultiplyBlending });
var cubeMaterial = new THREE.MeshDepthMaterial();
var sidemat = new THREE.MeshLambertMaterial({color: 0x66cc00});  
var insetmat = new THREE.MeshBasicMaterial({color: 0x66cc00});  
var saved_mat; 

var clock = new THREE.Clock();
var pivot = new THREE.Group(); 
var group = new THREE.Object3D();

var projector = new THREE.Projector();
var mouse = { x: 0, y: 0 };

displaymodes = { a: false, b: false }  
eddyvariables = { a: false, b: false, c: false } 
var currentDataFile = '';
var generalcontrols, eddyproperties;
var temp_max=0, temp_min=0, salt_max=0, salt_min=0, speed_max=0, speed_min=0;
var eddy_num = 0, distance = 0;
var spin_orientation = 0;
var currentEddyID = 1;

var infoWindow;

var CANVAS_WIDTH = 270, CANVAS_HEIGHT = 180, CAM_DISTANCE = 10;
var shiftscale = 15;



init();
animate();

function init() 
{		
	  generalcontrols = new function () 
	  {
        this.rotationSpeed = 0.02;
        this.bouncingSpeed = 0.03;

        this.visible = mainmat.visible;
        this.side = "front";
        
        this.transparent = mainmat.transparent;

        this.wireframe = mainmat.wireframe;
        this.wireframeLinewidth = mainmat.wireframeLinewidth;

        this.selectedMesh = "Temperature";
        this.shadow = "flat";
    };
    
    
    eddyproperties = function ()
    {
    	  this['Date'] = '0'; 
    	  this['Orientation'] = '0';
    	  this['Depth'] = '0'; 
    	  this['Radius'] = '0';
    	  this['Volume'] = '0';
    	  this['Distance'] = '0';
    	  this['Duration'] = '0';
    };
    	
		canvas = document.getElementById( "mycanvas" );		
		    
	  maincamera = new THREE.PerspectiveCamera(60, (window.innerWidth-160) / window.innerHeight, 0.1, 1000);  	  
	  maincamera.position.x = 0;
    maincamera.position.y = 0;
    maincamera.position.z = 2.5;

		template = document.getElementById( "template" ).text;			
		content = document.getElementById( "content" );		

    readcolorfile ("seashorergb.txt", 0);  
    readcolorfile ("parula.txt", 1); 
    readcolorfile ("gnuplot.txt", 2);    
    readcolorfile ("dawnrgb.txt", 3);       
        
    eddyvariables['a'] = true;					
    
    maincontent = document.getElementById( "maincontent" );
    mainscene = new THREE.Scene();
    
    var mainelement = document.createElement( "div" );
		mainelement.className = "main-item";

	  mainscene.userData.element = mainelement.querySelector( ".graph" );
		maincontent.appendChild( mainelement );
    
	  	  	  
	  trackballControls = new THREE.TrackballControls(maincamera);
    trackballControls.rotateSpeed = 1.0;
    trackballControls.zoomSpeed = 1.0;
    
    //trackballControls.minDistance = 0.1;
    trackballControls.maxDistance = 45;
    
    trackballControls.panSpeed = 1.0;
    trackballControls.noPan = false;
    trackballControls.staticMoving = false;
    trackballControls.dynamicDampingFactor = 0.3;
    trackballControls.keys = [ 65, 83, 68 ];
       
	  
	  var hemilight = new THREE.HemisphereLight( 0xaaaaaa, 0xFF0000 );
		hemilight.position.set( 1, 1, 10 );
		mainscene.add( hemilight );
		
		var ambiColor = "#0c0c0c";
    var ambientLight = new THREE.AmbientLight(ambiColor);
    mainscene.add( ambientLight );
				

    renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );
		//renderer.setPixelRatio( window.devicePixelRatio );			
		renderer.setSize( canvas.clientWidth, canvas.clientHeight, false );	
		
		document.addEventListener("dblclick", ondblclick, false);		
	
	  gui = new dat.GUI({ autoPlace: false });
    gui.domElement.id = 'gui';
      
    maincontent.appendChild(gui.domElement);	
     
    
    var GuiConfig = function() 
    {
        this['File Name'] = 'No Data Loaded'; 
        this['Load a *.path File'] = function() 
        {        	        	
            var input = document.getElementById("myInput");
                
            input.addEventListener('change', function(evt) 
            {                          
                for (var i in gui.__controllers) 
                {
                    gui.__controllers[i].updateDisplay();
                } 
                
                var filelist = evt.target.files;
                currentDataFile = filelist[0];
                
                config['File Name'] = currentDataFile.name;                    
                
                filename = currentDataFile.name;          
                
                readdatafile(currentDataFile);                                                            
            });
        
            input.click();
        };
        
        
        this['Export Data Information'] = function() 
        {  
        	  if (infoWindow != null && ! infoWindow.closed)
            	 infoWindow.close();
            	 
            var Depth_Max = round(Math.max.apply(null, depth_array), 2);
            var Depth_Min = round(Math.min.apply(null, depth_array), 2);
            var Radius_Max = round(Math.max.apply(null, radius_array), 2); 
            var Radius_Min = round(Math.min.apply(null, radius_array), 2); 
            var Volume_Max = round(Math.max.apply(null, volume_array), 2); 
            var Volume_Min = round(Math.min.apply(null, volume_array), 2);                     
             
            var Depth_Sum=0, Radius_Sum=0, Volume_Sum=0;
             
            for (var i1=0; i1<depth_array.length; i1++)
            {    	   	  
             	  Depth_Sum = Depth_Sum + depth_array[i1];
             	  Radius_Sum = Radius_Sum + radius_array[i1];
             	  Volume_Sum = Volume_Sum + volume_array[i1];             	 
            }
         
             
            var Depth_Avg = round(Depth_Sum/depth_array.length, 2), Radius_Avg = round(Radius_Sum/depth_array.length, 2), Volume_Avg = round(Volume_Sum/depth_array.length, 2);
            	 
            
            var showtext = "###### Information of the Eddy Path ######".bold() + '<br>';
            
            //showtext = showtext + temp_min + '&nbsp' + temp_max + '&nbsp' + salt_min + '&nbsp' + salt_max + '&nbsp' + speed_min + '&nbsp' + speed_max + '<br>' + '<br>';
            
            
            showtext = showtext + "- File Name: ".bold() + filename + '<br>' + '<br>';
            showtext = showtext + "- Number of Steps: ".bold() + '&nbsp' + depth_array.length + '<br>' + '<br>'; 
                        
            showtext = showtext + "- Distance (km): ".bold() + '&nbsp' + round(distance, 2) + '<br>' + '<br>'; 
            showtext = showtext + "- Duration : ".bold() + '&nbsp' + dateperiod + '<br>' + '<br>';
                                                
            showtext = showtext + "- Depth (m)".bold() + '&nbsp &nbsp' + "Max: " + Depth_Max + '&nbsp &nbsp &nbsp' + "Min: " + Depth_Min + '&nbsp &nbsp &nbsp' + "Avg.: " + Depth_Avg + '<br>' + '<br>';                
            showtext = showtext + "- Radius (km)".bold() + '&nbsp &nbsp' + "Max: " + Radius_Max + '&nbsp &nbsp &nbsp' + "Min: " + Radius_Min + '&nbsp &nbsp &nbsp' + " Avg.: " + Radius_Avg + '<br>' + '<br>';                                                           
            showtext = showtext + "- Volume (km3)".bold() + '&nbsp &nbsp' + "Max: " + Volume_Max + '&nbsp &nbsp &nbsp' + "Min: " + Volume_Min + '&nbsp &nbsp &nbsp' + " Avg.: " + Volume_Avg + '<br>' + '<br>';           
             
            showtext = showtext + "- Temperature ".bold() + '&nbsp &nbsp' + "Max: " + temp_max + '&nbsp &nbsp &nbsp' + "Min: " + temp_min + '<br>' + '<br>';
            showtext = showtext + "- Salinity (g/kg)".bold() + '&nbsp &nbsp' + "Max: " + salt_max + '&nbsp &nbsp &nbsp' + "Min: " + salt_min + '<br>' + '<br>';
            showtext = showtext + "- Speed (m/s)".bold() + '&nbsp &nbsp' + "Max: " + speed_max + '&nbsp &nbsp &nbsp' + "Min: " + speed_min + '<br>' + '<br>' + '<br>'; 
                                                                           
            showtext = showtext + "###### Information of the Selected Eddy ######".bold() + '<br>';
                
            showtext = showtext + "- Eddy ID: ".bold() + currentEddyID + '<br>' + '<br>';
            showtext = showtext + "- Depth (m): ".bold()+ round(depth_array[currentEddyID-1], 2) + '<br>' + '<br>'; 
            showtext = showtext + "- Radius (km): ".bold()+ round(radius_array[currentEddyID-1], 2) + '<br>' + '<br>'; 
            showtext = showtext + "- Volume (km3): ".bold()+ round(volume_array[currentEddyID-1], 2) + '<br>' + '<br>'; 
                
            showtext = showtext + "- Temperature ".bold() + '&nbsp &nbsp' + "Max: " + round(minmaxarray[currentEddyID-1].tmax, 2) + '&nbsp &nbsp &nbsp' + "Min: " + round(minmaxarray[currentEddyID-1].tmin, 2) + '<br>' + '<br>';
            showtext = showtext + "- Salinity (g/kg)".bold() + '&nbsp &nbsp' + "Max: " + round(minmaxarray[currentEddyID-1].stmax, 2) + '&nbsp &nbsp &nbsp' + "Min: " + round(minmaxarray[currentEddyID-1].stmin, 2) + '<br>' + '<br>';
            showtext = showtext + "- Speed (m/s)".bold() + '&nbsp &nbsp' + "Max: " + round(minmaxarray[currentEddyID-1].spdmax, 2) + '&nbsp &nbsp &nbsp' + "Min: " + round(minmaxarray[currentEddyID-1].spdmin, 2) + '<br>' + '<br>';
                                    	 
            infoWindow = window.open("", "Information Window", "width=480,height=720");   
            infoWindow.document.write(showtext);   
        };                
    };
    
                 
    var config = new GuiConfig();
    gui.add(config, 'Load a *.path File'); 
    gui.add(config, 'Export Data Information'); 
    gui.add(config, 'File Name', config['File Name']);
    
    eddypro = new eddyproperties();
    gui.add(eddypro, 'Date', eddypro['Date']);  
    gui.add(eddypro, 'Orientation', eddypro['Orientation']);  
    gui.add(eddypro, 'Duration', eddypro['Duration']);
    gui.add(eddypro, 'Distance', eddypro['Distance']);
               
    gui.add(displaymodes, 'a').name('Individual Eddy').listen().onChange(function(){setMode("a")});
    gui.add(displaymodes, 'b').name('Whole Eddy Path').listen().onChange(function(){setMode("b")});
    
    
    //var spGui = gui.addFolder("\xa0 Visualization Options");       
    //spGui.add(generalcontrols, 'transparent').onChange(function (e) { mainmat.transparent = e });        
    gui.add(generalcontrols, 'wireframe').onChange(function (e) { mainmat.wireframe = e });
    //spGui.add(generalcontrols, 'visible').onChange(function (e) { mainmat.visible = e });
        
    
    var vpGui = gui.addFolder("\xa0 Color Coding Options");
    gui.add(eddyvariables, 'a').name('Temperature').listen().onChange(function(){setVariable("a")});
    gui.add(eddyvariables, 'b').name('Salinity').listen().onChange(function(){setVariable("b")});
    gui.add(eddyvariables, 'c').name('Speed').listen().onChange(function(){setVariable("c")});    
    
    var ifGui = gui.addFolder("\xa0 Information of the Selected Eddy");       
    gui.add(eddypro, 'Depth', eddypro['Depth']);
    gui.add(eddypro, 'Radius', eddypro['Radius']);
    gui.add(eddypro, 'Volume', eddypro['Volume']);    


    gui.__ul.childNodes[0].childNodes[0].childNodes[0].classList += ' full_width'; 
    gui.__ul.childNodes[1].childNodes[0].childNodes[0].classList += ' full_width'; 
    
    
  
    scene2 = new THREE.Scene();       
    renderer2 = new THREE.WebGLRenderer({ alpha: true });
    renderer2.setClearColor( 0xffffff, 0.00 );
    renderer2.setSize( CANVAS_WIDTH, CANVAS_HEIGHT );

    container2 = document.getElementById('inset');
    container2.appendChild( renderer2.domElement );    
    
    window.addEventListener( 'resize', onWindowResize, false );            
}



function readcolorfile (colorfile, sign)
{
    var xhttp0 = new XMLHttpRequest();
    xhttp0.onreadystatechange = function() 
    {
        	 if (this.readyState == 4 && this.status == 200) 
        	 {
        	  	 var inputlines = this.responseText.split("\n");
        	  	 
        	  	 for (var i=0; i<inputlines.length; i++)
               {
               	   var thisline = inputlines[i];
              	   var vectors = thisline.split("  ");
              	   
              	   if (sign == 0)
              	   {
              	      temparray0.push(parseFloat(vectors[0]));
              	      redarray0.push(parseFloat(vectors[1]));
              	      greenarray0.push(parseFloat(vectors[2]));
              	      bluearray0.push(parseFloat(vectors[3]));
              	   }
              	   
              	   else if (sign == 1)
              	   {
              	      temparray1.push(parseFloat(vectors[0]));
              	      redarray1.push(parseFloat(vectors[1]));
              	      greenarray1.push(parseFloat(vectors[2]));
              	      bluearray1.push(parseFloat(vectors[3]));
              	   }
              	   
              	   else if (sign == 2)
              	   {
              	      temparray2.push(parseFloat(vectors[0]));
              	      redarray2.push(parseFloat(vectors[1]));
              	      greenarray2.push(parseFloat(vectors[2]));
              	      bluearray2.push(parseFloat(vectors[3]));
              	   }
              	   
              	   else if (sign == 3)
              	   {
              	      temparray3.push(parseFloat(vectors[0]));
              	      redarray3.push(parseFloat(vectors[1]));
              	      greenarray3.push(parseFloat(vectors[2]));
              	      bluearray3.push(parseFloat(vectors[3]));
              	   }
               }
        	 }
    }
       
    xhttp0.open("GET", colorfile, true);
    xhttp0.send();   
}





function readdatafile(datafile)
{
	  var reader = new FileReader();  
	                
    reader.onload = function(e) 
    {                 	
       document.getElementById("content").innerHTML = "";
       elementlist = [], geometrylist = [], materiallist = [], targetList = [];
       depth_array = [], radius_array = [], mapradius_array = [], volume_array = [], cx_array = [], cy_array = [], cz_array = [], minmaxarray = [];
                	
       var text = e.target.result;                
       var inputlines = text.split(/[\r\n]+/g); 
       
       
       var file_extension = inputlines[0];
       
       if (file_extension != "******path******")
       {
       	  alert("The File Can Not be Readed! Please Select a *.path File.");
          return;
       }
       
    	 var date_period = inputlines[1].split("  "); 
    	 var date_start = date_period[0];
    	 var date_end = date_period[1];
       dateperiod = date_start + " - " + date_end;      
       eddypro['Date'] = dateperiod;
       
       var pathproperties = inputlines[2].split(" "); 
       temp_min = parseFloat(pathproperties[0]);
       temp_max = parseFloat(pathproperties[1]);
       salt_min = parseFloat(pathproperties[2]);
       salt_max = parseFloat(pathproperties[3]);
       speed_min = parseFloat(pathproperties[4]);
       speed_max = parseFloat(pathproperties[5]);
       
       if (eddyvariables['a'] == true)
	     {
	  	    legendleft = temp_min;
          legendright = temp_max;
	     }
	  
	     else if (eddyvariables['b'] == true)
	     {
	  	    legendleft = salt_min;
          legendright = salt_max;
	     }

	     else if (eddyvariables['c'] == true)
	     {
	  	    legendleft = parseFloat(speed_min);
          legendright = parseFloat(speed_max);
	     }
	     
	     //console.log(legendleft);
	     //console.log(legendright);
       
       
       spin_orientation = parseInt(inputlines[3]);
       
       if (spin_orientation >= 0)
       {
          sidemat = new THREE.MeshLambertMaterial({color: 0x66cc00}); 
          insetmat = new THREE.MeshBasicMaterial({color: 0x00CC00}); 
          
          eddypro['Orientation'] = "Counter-Clockwise";   
       } 
          
       else if (spin_orientation < 0)
       {
          sidemat = new THREE.MeshLambertMaterial({color: 0x6600cc});
          insetmat = new THREE.MeshBasicMaterial({color: 0x4C0099}); 
          
          eddypro['Orientation'] = "Clockwise";   
       }
       
       distance = 0, eddy_num = 0;
           	  
       for (var i=4; i<inputlines.length; i++)
       {
           var thisline = inputlines[i];
           var vectors = thisline.split(" ");
              	          	               	                	  
           if ( vectors.length == 3 && parseInt(vectors[0])==155 && parseInt(vectors[1])==155 )
           { 
           	  eddy_num++;                 	
              var verticecolor_red = [], verticecolor_green = [], verticecolor_blue = [];

              i++;              	    
              thisline = inputlines[i];              	    
              var vectors1 = thisline.split(" ");              	    
              var volume = parseInt(vectors1[0]);
              var center_x = parseFloat(vectors1[1]);
              var center_y = parseFloat(vectors1[2]);
              var center_z = parseFloat(vectors1[3]);
              var low_x = parseFloat(vectors1[4]);
              var low_y = parseFloat(vectors1[5]);
              var low_z = parseFloat(vectors1[6]);
              var up_x = parseFloat(vectors1[7]);
              var up_y = parseFloat(vectors1[8]);
              var up_z = parseFloat(vectors1[9]);              	                    
              
              var mapradius = 0.5*Math.sqrt((up_x-low_x)*(up_y-low_y));  
              var thisradius = 111*mapradius*Math.cos( (center_y/180)*Math.PI  );             
                         	    
              depth_array.push( 1000.0*(up_z - low_z) );
              mapradius_array.push( mapradius );  
              radius_array.push( thisradius );                	    
              volume_array.push( thisradius*thisradius*(up_z - low_z) );              	    
              	                  	    
              i++;              	    
              thisline = inputlines[i];              	    
              var vectors2 = thisline.split(" ");
              	    
              var points_num = parseInt(vectors2[0]);
              var this_tmin = parseFloat(vectors2[1]);
              var this_tmax = parseFloat(vectors2[2]);
              var this_stmin = parseFloat(vectors2[3]);
              var this_stmax = parseFloat(vectors2[4]);
              var this_spdmin = parseFloat(vectors2[5]);
              var this_spdmax = parseFloat(vectors2[6]);
              	    
              var currentmm = {tmin: this_tmin, tmax: this_tmax, stmin: this_stmin, stmax: this_stmax, spdmin: this_spdmin, spdmax: this_spdmax};              	    
              minmaxarray.push(currentmm);
              	                  	    
             	    
              var eddygeometry = new THREE.Geometry();   
              var j;
              	                 	                  	     
              for (j=i+1; j<i+points_num+1; j++)
              {
              	  thisline = inputlines[j];
              	  var coordinates = thisline.split(" ");
              	  eddygeometry.vertices.push( new THREE.Vector3( parseFloat( coordinates[0] ), parseFloat( coordinates[1] ), parseFloat( coordinates[2]) ) );
              	     	  
              	  var getindex;          	         
              	                      	        
              	  if (eddyvariables['a'] == true)
              	  {
              	     getindex = findcolor( parseFloat(coordinates[3]), 0.99*temp_min, 1.01*temp_max, spin_orientation); 
              	        	 
              	     if (spin_orientation==1)
              	     {
                        verticecolor_red.push(redarray0[getindex]);
                        verticecolor_green.push(greenarray0[getindex]);
              	        verticecolor_blue.push(bluearray0[getindex]);
              	     }
              	           
              	     else if (spin_orientation==-1)
              	     {
                        verticecolor_red.push(redarray3[getindex]);
                        verticecolor_green.push(greenarray3[getindex]);
              	        verticecolor_blue.push(bluearray3[getindex]);
              	     }
                  }
       
                  else if (eddyvariables['b'] == true)
                  {
                     getindex = findcolor( parseFloat(coordinates[4]), 0.99*salt_min, 1.01*salt_max, spin_orientation);
                     verticecolor_red.push(redarray1[getindex]);
                     verticecolor_green.push(greenarray1[getindex]);
              	     verticecolor_blue.push(bluearray1[getindex]);
                  }
       
                  else if (eddyvariables['c'] == true)
                  {
                     getindex = findcolor( parseFloat(coordinates[5]), 0.99*speed_min, 1.01*speed_max, spin_orientation);
                     verticecolor_red.push(redarray2[getindex]);
                     verticecolor_green.push(greenarray2[getindex]);
              	     verticecolor_blue.push(bluearray2[getindex]);
              	  }           	     	  
              }
              	     
              i = j;
              	                  	     
              var faces_num_string = inputlines[i];
              var faces_num = parseInt(faces_num_string);
              	     
              for (j=i+1; j<i+faces_num+1; j++)
              {
              	  thisline = inputlines[j];
              	  var coordinates = thisline.split(" ");
              	     	                 	     	   
              	  eddygeometry.faces.push( new THREE.Face3( parseInt( coordinates[1] ), parseInt( coordinates[2] ), parseInt( coordinates[3]) ) );
              	                 	    
              	  var color_p1 = new THREE.Color( 0xff0000 );
              	  color_p1.setRGB( verticecolor_red[parseInt(coordinates[1])], verticecolor_green[parseInt(coordinates[1])], verticecolor_blue[parseInt(coordinates[1])] );
              	         
              	  var color_p2 = new THREE.Color( 0x00ff00 );
              	  color_p2.setRGB( verticecolor_red[parseInt(coordinates[2])], verticecolor_green[parseInt(coordinates[2])], verticecolor_blue[parseInt(coordinates[2])] );
              	         
              	  var color_p3 = new THREE.Color( 0x0000ff );
              	  color_p3.setRGB( verticecolor_red[parseInt(coordinates[3])], verticecolor_green[parseInt(coordinates[3])], verticecolor_blue[parseInt(coordinates[3])] );
              	                       	         
              	  face = eddygeometry.faces[j-i-1];	
              	  face.vertexColors[0] = color_p1;
              	  face.vertexColors[1] = color_p2;
              	  face.vertexColors[2] = color_p3;              	    
              } 
              	     
              i = j;  
              	     
              eddygeometry.computeFaceNormals();
              eddygeometry.computeVertexNormals();
              eddygeometry.computeBoundingSphere();
                    

              geometrylist.push(eddygeometry);			              
			        materiallist.push(mainmat);
			              
			        currentmesh = new THREE.Mesh(eddygeometry, sidemat);		              
			        currentmesh.castShadow = true;
              currentmesh.receiveShadow = true;		
              
              currentmesh.scale.set(1, 1, 1.1);
                
              
              var scene = new THREE.Scene();
			        var element = document.createElement( "div" );
			        element.id = eddy_num;
			        element.className = "list-item";
			        element.innerHTML = template.replace( '$', eddy_num );			         
			  			  
				      scene.userData.element = element.querySelector( ".scene" );
				      content.appendChild( element );		    
              
              
              var thisbox = new THREE.Box3().setFromObject( currentmesh );
					    var boxx = thisbox.max.x - thisbox.min.x;
					    var boxy = thisbox.max.y - thisbox.min.y;					
					    var diameter = Math.max(boxx, boxy);	
					    
					    //console.log(diameter);				    
					    
					    var camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);			              
				    	camera.position.x = 0;
              camera.position.y = 0;
							
              camera.position.z = 0.8+diameter;
              
	              
				      scene.userData.camera = camera;			            			
				      elementlist.push(element);         
              	  			  
				      scene.add( currentmesh );
				      scene.add( new THREE.HemisphereLight( 0xaaaaaa, 0x444444 ) );
				            		        
				            
				      var shiftx = currentmesh.geometry.boundingSphere.center.x;
				      var shifty = currentmesh.geometry.boundingSphere.center.y;
				      var shiftz = currentmesh.geometry.boundingSphere.center.z;      
				            
				      cx_array.push(shiftx);
				      cy_array.push(shifty);
				      cz_array.push(shiftz);
				            
				      currentmesh.geometry.translate( -shiftx, -shifty, -shiftz );
				      currentmesh.rotation.x = -Math.PI / 3 ;			
				      
				      
				      var clonegeometry = currentmesh.geometry.clone();
		          //var clonematerial = currentmesh.material.clone();
		          var currentmesh_clone = new THREE.Mesh(clonegeometry, insetmat);	
		          
		          //console.log(currentmesh);
			              
			        targetList.push(currentmesh_clone);  			                           

   	

				      var light = new THREE.DirectionalLight( 0xffffff, 0.5 );
				      light.position.set( 1, 1, 1 );
			        scene.add( light );			            	
				
				      scenes.push( scene );
				      //scene2.add( currentmesh );        	               	     
           }             	         	  
       }//for                                               
        
        
       var factor_sum = 0;
           
       for (var i2=0; i2<cx_array.length-1; i2++)
       { 
       	   var currentshift = geodistance(cy_array[i2], cx_array[i2], cy_array[i2+1], cx_array[i2+1], "K");    
           distance = distance + currentshift;  
           
           var mapdist =   Math.sqrt( (cx_array[i2+1]-cx_array[i2])*(cx_array[i2+1]-cx_array[i2]) + (cy_array[i2+1]-cy_array[i2])*(cy_array[i2+1]-cy_array[i2]) ); 
           var factor = (mapradius_array[i2+1] + mapradius_array[i2])/mapdist;
           //console.log(factor); 
           
           factor_sum = factor_sum + factor;
       }
       
       var avg_factor = factor_sum/(cx_array.length-1);
       shiftscale = 0.84*avg_factor;
       
       
    
       eddypro['Distance'] = round(distance, 2) + " km";
       eddypro['Duration'] = cx_array.length + " days";
                      
           
       elementlist.forEach( function( elm )            
		   {		       	
			        elm.addEventListener ("click", function() 
				      {   
					       currentEddyID = elm.id;					  					  
					       clickEddy(currentEddyID);
				      });
		   });
		       		       
		   setMode( 'a' );
		   	    		   
		   drawMiniature();		   		   		       	       
    };
    
    reader.readAsText(datafile,"UTF-8");  
}





function drawMiniature()
{
	  while (scene2.children.length > 0) 
          scene2.remove(scene2.children[0]); 
                
             
    var pivot2 = new THREE.Group(); 
    var group2 = new THREE.Object3D();
       
       var center_x = 0.5*(Math.min.apply(null, cx_array) + Math.max.apply(null, cx_array));
	     var center_y = 0.5*(Math.min.apply(null, cy_array) + Math.max.apply(null, cy_array));
	     
		   
		   for (var i2=0; i2<targetList.length; i2++)
		   {         
           targetList[i2].position.set( 0.8*shiftscale*(cx_array[i2] - center_x), 0.8*shiftscale*(cy_array[i2] - center_y), 0 );                     
           group2.add( targetList[i2] );	         
		   }                
		   
		   scene2.add( pivot2 );			   
		   pivot2.add( group2 );

       pivot2.rotation.x = -Math.PI / 3 ;
       //pivot2.rotation.z = -0.3*Math.PI; 
       
       var path_width = 0.8*shiftscale * (Math.max.apply(null, cx_array) -  Math.min.apply(null, cx_array));	 
       var path_depth = 0.8*shiftscale * (Math.max.apply(null, cy_array) -  Math.min.apply(null, cy_array));	
       
       //console.log(Math.max(path_width, path_depth));
  
         
	     CAM_DISTANCE = 0.81*Math.max(path_width, path_depth);
	     
	     if (CAM_DISTANCE>28)
	        CAM_DISTANCE = 28;
	     
       
       //pivot2.position.x += 0.1*path_width ;
       		   
		   var light2 = new THREE.HemisphereLight( 0xaaaaaa, 0xFFFFCC );
		   light2.position.set( 0, 0, 5 );
		   scene2.add( light2 );
		    
       var directionlight = new THREE.DirectionalLight( 0xffffff, 0.5 );
		   directionlight.position.set( 0, 0, 10 );
	     scene2.add( directionlight );   
}





function setMode( prop )
{
    for (let param in displaymodes)
        displaymodes[param] = false;

    displaymodes[prop] = true;

    while (mainscene.children.length > 0) 
          mainscene.remove(mainscene.children[0]);           
          
    drawColorbar(legendleft, legendright, spin_orientation);

    if (prop=='a')
    {    	
    	 maincamera.position.z = 2.5;
       clickEddy(currentEddyID);   
       trackballControls.reset();   
       
       container2.style.backgroundColor = "rgba(235,235,235,0.5)";
        
       drawMiniature();      
    }
  
    else if (prop=='b')
    { 
    	 //maincamera.position.z = 8;
    	     	 
    	 pivot = new THREE.Group(); 
       group = new THREE.Object3D();
       
       while (scene2.children.length > 0) 
             scene2.remove(scene2.children[0]); 
          
       container2.style.backgroundColor = "rgba(255,255,255,0.0)";  
       
           axes = drawAxes( 65 );
    scene2.add( axes );    
    CAM_DISTANCE = 200;
       
       displayData();
       clickEddy(currentEddyID); 
    }
}



function clickEddy(thisindex)
{	
	  for (var i1=0; i1<targetList.length; i1++)
	      targetList[i1].material= insetmat;
	  
	  targetList[thisindex-1].material = new THREE.MeshBasicMaterial({color: 0xFF0000}); 
	  	  
	  elementlist.forEach( function( elm )            
		{		       	
				elm.style.border = "thick solid #FFFFFF"; 				
		});
		
		
		elementlist.forEach( function( elm )            
		{
				if (elm.id == thisindex)
				   elm.style.border = "thick solid #FF8000";
	  });
	  
    addColorRange( thisindex );
       
    eddypro['Depth'] = round(depth_array[thisindex-1], 2) + " m";
    eddypro['Radius'] = round(radius_array[thisindex-1], 2) + " km";
    eddypro['Volume'] = round(volume_array[thisindex-1], 2) + " km3";
    
    for (var i in gui.__controllers) 
    {
        gui.__controllers[i].updateDisplay();
    }
	  

	  
	  if (displaymodes['a'] == true)
	  {	  	
	     var newGeometry = geometrylist[thisindex-1];
       var newMaterial = materiallist[thisindex-1];  

       mainscene.remove(mainmesh);

       mainmesh = new THREE.SceneUtils.createMultiMaterialObject(newGeometry, [newMaterial, cubeMaterial]);   
       mainmesh.rotation.x = -Math.PI / 3 ;
       mainmesh.scale.set(1, 1, 1.3);
    	 
	     mainscene.add( mainmesh );		     	     
	  }
	  
	 	  
	  
	  else if (displaymodes['b'] == true)
	  {  	 
	  	 var i = 0;
	  	 meshlist.forEach( function( elm )            
	     {		       	
				   var this_r = meshlist[i].material.color.r;	
				   var this_g = meshlist[i].material.color.g;
	  	  	 var this_b = meshlist[i].material.color.b;		
	  	  	 
	  	  	 if ( this_r == 1 && this_g == 0 && this_b == 0 )
	  	  	    meshlist[i].material = saved_mat.clone( );
	  	  	    
	  	  	 i++;
		   });
	  	 
	  	 saved_mat = meshlist[thisindex-1].material.clone( );
	  	 meshlist[thisindex-1].material = new THREE.MeshBasicMaterial({color: 0xFF0000}); 
	  }	  	  
}




function displayData()
{    
    var i1 = 0;
    meshlist = [];
    
    var center_x = 0.5*(Math.min.apply(null, cx_array) + Math.max.apply(null, cx_array));
	  var center_y = 0.5*(Math.min.apply(null, cy_array) + Math.max.apply(null, cy_array));
	  
	  var line_mat = new THREE.MeshBasicMaterial({color: 0x000000}); 
	  //var arrow_mat = new THREE.MeshBasicMaterial({color: 0xFF0000}); 
	  
    
    elementlist.forEach( function( elm )            
		{
			  var newGeometry = geometrylist[i1];
        var newMaterial = materiallist[i1];                 
        
 /*
        if (spin_orientation >= 0)        
           currentmesh = new THREE.Mesh( newGeometry, new THREE.MeshLambertMaterial( { color: 0x66cc00, transparent: true, opacity: 0.75 } ));       
          
        else if (spin_orientation < 0)
        	 currentmesh = new THREE.Mesh( newGeometry, new THREE.MeshLambertMaterial( { color: 0x6600cc, transparent: true, opacity: 0.75 } )); 
*/
 
        currentmesh = new THREE.Mesh( newGeometry, newMaterial );       
 
        currentmesh.castShadow = true;
        currentmesh.receiveShadow = true;           
        currentmesh.position.set( shiftscale*(cx_array[i1] - center_x), shiftscale*(cy_array[i1] - center_y), 0 );
        currentmesh.name = i1+1;
          
        currentmesh.scale.set(1, 1, 1.3);
        			
				group.add( currentmesh );
				meshlist.push(currentmesh);
				
				
				var line_gap = 0.5;
				
				if (round(Math.max.apply(null, depth_array), 1) > 600)
				   line_gap = round(Math.max.apply(null, depth_array), 1)/1300;
		
				if (i1 < elementlist.length-1)
				{	
				   var src_x = shiftscale*(cx_array[i1] - center_x); 				
					 var src_y = shiftscale*(cy_array[i1] - center_y);
					 var src_z = line_gap; 
					 
					 var dst_x = shiftscale*(cx_array[i1+1] - center_x); 
					 var dst_y = shiftscale*(cy_array[i1+1] - center_y);
					 var dst_z = line_gap; 
					  
				   if (i1 < elementlist.length-2)	
				   {	 
			        var directionline = cylinderLine(new THREE.Vector3(src_x, src_y, src_z), new THREE.Vector3(dst_x, dst_y, dst_z), 0.02, 0.02, line_mat);				   
				      group.add( directionline );
			     }
			     
			     else
			     {
			     	  var endarrow = cylinderLine(new THREE.Vector3(src_x, src_y, src_z), new THREE.Vector3(dst_x, dst_y, dst_z), 0.12, 0, line_mat);				   
				      group.add( endarrow );
			     }		
		    }
			  
				i1++;
	  });
	  
	  
	  	 
	  
	  mainscene.add( pivot );
    pivot.add( group );

    pivot.rotation.x = -Math.PI / 3 ;
    //pivot.rotation.z = 0.4*Math.PI;  
    

     var path_width = shiftscale * (Math.max.apply(null, cx_array) -  Math.min.apply(null, cx_array));	 
     var path_depth = shiftscale * (Math.max.apply(null, cy_array) -  Math.min.apply(null, cy_array));	
            
	   maincamera.position.z= 0.6*Math.max(path_width, path_depth);
	   
	   pivot.position.x += 0.1*path_width ;
	        
	  
	  var directionlight = new THREE.DirectionalLight( 0xffffff );
    directionlight.position.set( 3, 3, 3 );
    mainscene.add( directionlight );
}



function setVariable( prop )
{
    for (let param in eddyvariables)
        eddyvariables[param] = false;

    eddyvariables[prop] = true;        
    readdatafile(currentDataFile);  
}





function onWindowResize() 
{
		maincamera.aspect = (window.innerWidth-160) / window.innerHeight;
	  maincamera.updateProjectionMatrix();

		renderer.setSize( canvas.clientWidth, canvas.clientHeight );
		trackballControls.handleResize();

		render();
}


			
function animate() 
{
		render();
		requestAnimationFrame( animate );
}



function render() 
{		
		var delta = clock.getDelta();       	
    trackballControls.update(delta);  
    

		renderer.setClearColor( 0xffffff );
		renderer.setScissorTest( false );
		renderer.clear();
		renderer.setScissorTest( true );


		scenes.forEach( function( scene ) 
		{
			    
			    if (spin_orientation < 0)
			       scene.children[0].rotation.z += 0.03;
			       
			    else if (spin_orientation > 0)
			    	 scene.children[0].rotation.z -= 0.03;
			    
			    //scene.children[0].rotation.z = Date.now() * 0.001;

					// get the element that is a place holder for where we want to draw the scene
					var element = scene.userData.element;

					// get its position relative to the page's viewport
					var rect = element.getBoundingClientRect();

					// check if it's offscreen. If so skip it
					if ( rect.bottom < 0 || rect.top  > renderer.domElement.clientHeight || rect.right  < 0 || rect.left > renderer.domElement.clientWidth ) 
						 return;  // it's off screen


					// set the viewport
					var width  = rect.right - rect.left;
					var height = rect.bottom - rect.top;
					var left   = rect.left;
					var top    = rect.top;

					renderer.setViewport( left, top, width, height );
					renderer.setScissor( left, top, width, height );

					var camera = scene.userData.camera;
					renderer.render( scene, camera );
		});
	
		renderer.setViewport( 0, 0, window.innerWidth-160, window.innerHeight );
	  renderer.setScissor( 0, 0, window.innerWidth-160, window.innerHeight );
		renderer.render( mainscene, maincamera );		
		
		camera2 = new THREE.PerspectiveCamera( 60, CANVAS_WIDTH / CANVAS_HEIGHT, 0.1, 1000 );
		camera2.position.copy( maincamera.position );
		//camera2.position.x = 0;
			
	  camera2.position.setLength( CAM_DISTANCE );
    camera2.lookAt( scene2.position );
            
    renderer2.render( scene2, camera2 );
}







function findcolor(thistemp, mintemp, maxtemp, spin_sign) 
{	
	  var temparray = [];
	
	  if (eddyvariables['a'] == true)
	  {
	  	 if (spin_sign==1)
          temparray = temparray0.slice();
          
       else if (spin_sign==-1)
       	  temparray = temparray3.slice();
    }
       
    else if (eddyvariables['b'] == true)
       temparray = temparray1.slice();
       
    else if (eddyvariables['c'] == true)
       temparray = temparray2.slice();
       
       //console.log(temparray.length);
			
	        	
    var colorindex = -1;
    var color_num = temparray.length;
        	  
    if (thistemp <= mintemp)
       return 0;
        	     
    else if (thistemp >= maxtemp)
       return (color_num-1);
       
       
        	     
    else
    {
       var fragment = (thistemp - mintemp)/(maxtemp - mintemp);
       var difference = 1;
        	  
       for (var i=0; i<color_num; i++)
       {
        	 if ( Math.abs(fragment - temparray[i]) > difference )
        	  	return i;
        	  	        
        	 else
        	  	difference = Math.abs(fragment - temparray[i]);
       }
    }     	  
}  



function buildAxis( src, dst, colorHex, dashed ) 
{
    var geom = new THREE.Geometry(), mat;

    if (dashed) 
        mat = new THREE.LineDashedMaterial({ linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3 });
    
    else 
        mat = new THREE.LineBasicMaterial({ linewidth: 3, color: colorHex });

    geom.vertices.push( src.clone() );
    geom.vertices.push( dst.clone() );
    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines

    var axis = new THREE.Line( geom, mat, THREE.LineSegments );
    return axis;
}
        
        
        
function coordAxes( length ) 
{
    var axes = new THREE.Object3D();

    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 0xFF0000, false ) ); // +X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( -length, 0, 0 ), 0xFF0000, true) ); // -X
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, length, 0 ), 0x00FF00, false ) ); // +Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, -length, 0 ), 0x00FF00, true ) ); // -Y
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, length ), 0x0000FF, false ) ); // +Z
    axes.add( buildAxis( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -length ), 0x0000FF, true ) ); // -Z

    return axes;
}       
        
        
function drawColorbar( mintemp, maxtemp, spin_sign )        
{
	
	  var cv  = document.getElementById('colorbarcanvas'),	  
    ctx = cv.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    
    var temparray = [], redarray = [], greenarray = [], bluearray = [];
	
	  if (eddyvariables['a'] == true)
	  {
	  	 if (spin_sign == 1)
	  	 {
          temparray = temparray0.slice();
          redarray = redarray0.slice();
          greenarray = greenarray0.slice();
          bluearray = bluearray0.slice();
       }
       
       else if (spin_sign == -1)
       {
          temparray = temparray3.slice();
          redarray = redarray3.slice();
          greenarray = greenarray3.slice();
          bluearray = bluearray3.slice();
       }
    }
       
    else if (eddyvariables['b'] == true)
    {
       temparray = temparray1.slice();
       redarray = redarray1.slice();
       greenarray = greenarray1.slice();
       bluearray = bluearray1.slice();
    }
       
    else if (eddyvariables['c'] == true)
    {
       temparray = temparray2.slice(); 
       redarray = redarray2.slice();
       greenarray = greenarray2.slice();
       bluearray = bluearray2.slice();
    }
    

    for (var i = 0; i < temparray.length-1; i++) 
    {        
        var currentRed = Math.floor(temparray.length*redarray[i]);
        var currentGreen = Math.floor(temparray.length*greenarray[i]);
        var currentBlue = Math.floor(temparray.length*bluearray[i]);
               
        ctx.fillStyle = 'rgb(' + currentRed + ', ' + currentGreen + ', ' + currentBlue + ')';            
        ctx.fillRect( 22 + (256/temparray.length)*i, 0, 256/temparray.length, 25);        
    } 
    
   
    ctx.fillStyle = 'rgb(0, 0, 0)';  
    ctx.font="Georgia bold 11px";    
    
    
    if (eddyvariables['a'] == true || eddyvariables['b'] == true)
    { 
       ctx.fillText(round(mintemp, 1), 0, 18);       
       ctx.fillText(round(maxtemp, 1), 279, 18); 
    }
    
    else if (eddyvariables['c'] == true)
    {
    	 ctx.fillText(mintemp, 10, 18);       
       ctx.fillText(maxtemp, 279, 18); 
    }
}



function addColorRange( thisindex )
{
	  var leftval, rightval, leftindex, rightindex, barwidth;	  
       
	  if (eddyvariables['a'] == true)
	  {
	  	 leftval = minmaxarray[thisindex-1].tmin;
       rightval = minmaxarray[thisindex-1].tmax;
       
       leftindex = findcolor(leftval, 0.99*temp_min, 1.01*temp_max, spin_orientation);
       rightindex = findcolor(rightval, 0.99*temp_min, 1.01*temp_max, spin_orientation);
       
       barwidth = 256/temparray0.length;
	  }
	  
	  else if (eddyvariables['b'] == true)
	  {
	  	 leftval = minmaxarray[thisindex-1].stmin;
       rightval = minmaxarray[thisindex-1].stmax;
       
       leftindex = findcolor(leftval, 0.99*salt_min, 1.01*salt_max, spin_orientation);
       rightindex = findcolor(rightval, 0.99*salt_min, 1.01*salt_max, spin_orientation);
       
       barwidth = 256/temparray1.length;
	  }

	  else if (eddyvariables['c'] == true)
	  {
	  	 leftval = minmaxarray[thisindex-1].spdmin;
       rightval = minmaxarray[thisindex-1].spdmax;
       
       leftindex = findcolor(leftval, 0.99*speed_min, 1.01*speed_max, spin_orientation);
       rightindex = findcolor(rightval, 0.99*speed_min, 1.01*speed_max, spin_orientation);
       
       barwidth = 256/temparray2.length;
	  }
	
	  var cv  = document.getElementById('colorbarcanvas'),	  
    ctx = cv.getContext('2d');
    ctx.clearRect(0, 25, canvas.width, canvas.height);
  
    ctx.fillStyle = 'rgb(255, 0, 0)'; 
    ctx.fillRect( 22 + leftindex*barwidth, 25, barwidth, 15);  
    ctx.fillStyle = 'rgb(255, 0, 0)';     
    ctx.fillRect( 22 + rightindex*barwidth, 25, barwidth, 15);  
    ctx.fillStyle = 'rgb(255, 0, 0)';  
    ctx.fillRect( 22 + leftindex*barwidth, 40, (rightindex-leftindex)*barwidth, barwidth);   
}




function geodistance(lat1, lon1, lat2, lon2, unit) 
{
	  var radlat1 = Math.PI * lat1/180
	  var radlat2 = Math.PI * lat2/180
	  var theta = lon1-lon2
	  var radtheta = Math.PI * theta/180
	  var dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
	  dist = Math.acos(dist)
	  dist = dist * 180/Math.PI
	  dist = dist * 60 * 1.1515
	  if (unit=="K") 
	     { dist = dist * 1.609344 }
	  if (unit=="N") 
	     { dist = dist * 0.8684 }
	
	  return dist
}




function round(value, decimals) 
{
    return Number(Math.round(value+'e'+decimals)+'e-'+decimals);
}



function cylinderLine(point1, point2, radius1, radius2, material) 
{
    var direction = new THREE.Vector3().subVectors(point2, point1);
    var orientation = new THREE.Matrix4();
    orientation.lookAt(point1, point2, new THREE.Object3D().up);
    orientation.multiply(new THREE.Matrix4().set(1, 0, 0, 0,
                                                 0, 0, 1, 0,
                                                 0, -1, 0, 0,
                                                 0, 0, 0, 1));
    var edgeGeometry = new THREE.CylinderGeometry(radius2, radius1, direction.length(), 10, 1);
    var edge = new THREE.Mesh(edgeGeometry, material);
    edge.applyMatrix(orientation);
    
    edge.position.x = (point2.x + point1.x) / 2;
    edge.position.y = (point2.y + point1.y) / 2;
    edge.position.z = (point2.z + point1.z) / 2;
    
    return edge;
}



function drawAxes( length ) 
{
    var axes = new THREE.Object3D();
    var material1 = new THREE.MeshBasicMaterial({color: 0xFF0000, transparent: true, opacity: 0.99});
    var material2 = new THREE.MeshBasicMaterial({color: 0xCC00CC, transparent: true, opacity: 0.99});
    var material3 = new THREE.MeshBasicMaterial({color: 0x0000FF, transparent: true, opacity: 0.99});
       

    axes.add( cylinderLine( new THREE.Vector3( -length, 0, 0 ), new THREE.Vector3( length, 0, 0 ), 2, 2, material1 ) ); 
    axes.add( cylinderLine( new THREE.Vector3( 0, -length, 0 ), new THREE.Vector3( 0, length, 0 ), 2, 2, material2 ) ); 
    axes.add( cylinderLine( new THREE.Vector3( 0, 0, -length ), new THREE.Vector3( 0, 0, length ), 2, 2, material3 ) ); 
    
    axes.add( cylinderLine( new THREE.Vector3( length, 0, 0 ), new THREE.Vector3( 1.2*length, 0, 0 ), 5, 0, material1 ) ); 
    axes.add( cylinderLine( new THREE.Vector3( 0, length, 0 ), new THREE.Vector3( 0, 1.2*length, 0 ), 5, 0, material2 ) ); 
    axes.add( cylinderLine( new THREE.Vector3( 0, 0, length ), new THREE.Vector3( 0, 0, 1.2*length ), 5, 0, material3 ) ); 
    
    axes.rotation.x -= Math.PI / 3 ;  


    return axes;
}



function ondblclick(event) 
{
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	  
	
	  var vector = new THREE.Vector3( mouse.x, mouse.y, -1 );
	  projector.unprojectVector( vector, maincamera );
	  var ray = new THREE.Raycaster( maincamera.position, vector.sub( maincamera.position ).normalize() );


	  var intersects = ray.intersectObjects( meshlist );

	
	  if ( intersects.length > 0 )
	  { 
        //console.log( parseInt(intersects[0].object.name) );	  
        currentEddyID = parseInt(intersects[0].object.name);					  					  
				clickEddy(currentEddyID);
					       
				var element = scenes[0].userData.element;					
				var rect = element.getBoundingClientRect();
				
				console.log(1.3*(currentEddyID-1)*[rect.bottom - rect.top]);
		 
			  window.scrollTo( 0, 1.3*(currentEddyID-1)*[rect.bottom - rect.top] );        
    }
}




</script>
</body>
</html>